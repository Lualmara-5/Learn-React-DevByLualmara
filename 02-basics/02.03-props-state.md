# 02.03 - Props y State en React

**Objetivo:** entender qu√© son las *props* y el *state*, cu√°ndo usar cada uno, c√≥mo tiparlos en **TypeScript (TSX)** y practicar con ejemplos paso a paso.

---

## üîπ ¬øQu√© son las *props*?

**Props** (properties) son datos que **un componente recibe desde su padre**.

Piensa: el componente hijo es una funci√≥n pura que *recibe par√°metros* (props) y renderiza UI seg√∫n esos valores.

### Caracter√≠sticas clave de las props

* Son **de solo lectura** dentro del componente hijo. No las debes mutar.
* Se usan para **configurar** o **personalizar** un componente (texto, URL de imagen, callbacks, flags).
* Se pasan desde el componente padre al hijo como atributos en JSX: `<MiComponente valor="algo" />`.

### Ejemplo b√°sico en TSX

```tsx
// Card.tsx
type CardProps = {
  name: string;
  career: string;
  hobby?: string; // opcional
};

export default function Card({ name, career, hobby }: CardProps) {
  return (
    <article style={{ border: "1px solid #ddd", padding: "12px", borderRadius: 8 }}>
      <h3>{name}</h3>
      <p>{career}</p>
      {hobby && <p>Hobby: {hobby}</p>}
    </article>
  );
}
```

```tsx
// App.tsx
import Card from "./Card";

export default function App() {
  return (
    <>
      <Card name="Alejo" career="Ing. de Sistemas" hobby="Guitarra" />
      <Card name="Mar√≠a" career="Dise√±o UX" />
    </>
  );
}
```

**Explicaci√≥n l√≠nea a l√≠nea (Card.tsx):**

-> `type CardProps = { ... }` esto significa ‚ÄúQuiero que el componente Card reciba un objeto con":

* **"un `name` que sea texto,"**
* **"una `career` que sea texto,"**
* **"y un `hobby` que puede venir o no (por eso el ?), tambi√©n texto.‚Äù**

Entonces si alguien usa tu componente, **TypeScript ya sabe qu√© debe recibir**:

‚úÖ Correcto:
```tsx
<Card name="Alejo" career="Ingeniero de Sistemas" hobby="Programar" />
```

‚úÖ Tambi√©n correcto (porque `hobby` es opcional):
```tsx
<Card name="Alejo" career="Ingeniero de Sistemas" />
```

‚ùå Incorrecto (TypeScript grita):
```tsx
<Card name={123} career="Ingeniero" />
```
> Error: number no es asignable a string.

<br>

-> `Card({ name, career, hobby }: CardProps)`

Esta parte tiene dos cosas mezcladas:

**a. Desestructuraci√≥n**

`({ name, career, hobby })`

Significa que el componente recibe un objeto (los props) y **extrae** esos tres valores directamente, en vez de escribir `props.name`, `props.career`, etc.

Sin desestructurar ser√≠a:
```tsx
function Card(props: CardProps) {
  return <h3>{props.name}</h3>;
}
```

Con desestructuraci√≥n (m√°s limpio):
```tsx
function Card({ name, career, hobby }: CardProps) {
  return <h3>{name}</h3>;
}
```

**b. El `: CardProps`**

Eso le dice a TypeScript:

> ‚ÄúEste par√°metro (lo que recibe la funci√≥n) debe cumplir con las reglas del tipo `CardProps`.‚Äù

O sea, **asegura que los props tengan esa forma**, si alguien pasa algo distinto, TypeScript te avisa.

-> `{hobby && <p>Hobby: {hobby}</p>}`

Esa l√≠nea es una forma elegante de **mostrar algo solo si existe** el valor `hobby`.

En JavaScript/React:

* Si `hobby` **tiene un valor**, se muestra `<p>Hobby: {hobby}</p>`.
* Si `hobby` est√° **vac√≠o o no se envi√≥, no muestra nada**.

El operador `&&` funciona como un **‚Äúsi existe, haz esto‚Äù**.

Ejemplo mental:

```tsx
// Si hobby = "Programar"
{hobby && <p>Hobby: Programar</p>} // ‚úÖ se muestra

// Si hobby = undefined
{hobby && <p>Hobby: Programar</p>} // ‚ùå no se muestra nada
```

---

### üö´ Versi√≥n sin TypeScript (solo React JS)

```jsx
// Card.jsx
export default function Card({ name, career, hobby }) {
  return (
    <article style={{ border: "1px solid #ddd", padding: "12px", borderRadius: 8 }}>
      <h3>{name}</h3>
      <p>{career}</p>
      {hobby && <p>Hobby: {hobby}</p>}
    </article>
  );
}
```

Y la podr√≠as usar as√≠:

```jsx
<Card name="Alejo" career="Ingeniero de Sistemas" hobby="Programar" />
```

Todo bien ‚úÖ
Pero‚Ä¶ mira lo que pasa si cometes errores üëá

#### ‚ùå Error #1: Pasar tipos equivocados
```jsx
<Card name={123} career={true} hobby={["Correr", "Jugar"]} />
```

JavaScript no se queja üòê
El navegador simplemente muestra:

```vbnet
123
true
Hobby: Correr,Jugar
```

Y t√∫ ni te enteras de que algo sali√≥ mal, aunque conceptualmente est√° raro.

#### ‚ùå Error #2: Olvidar una propiedad obligatoria
```jsx
<Card name="Alejo" />
```

Esto tambi√©n se ejecuta, pero te muestra algo como:

```jsx
Alejo
undefined
```

Y t√∫ piensas ‚Äú¬øpor qu√© sale undefined?‚Äù üòÖ

No hay ning√∫n aviso.

#### ‚ùå Error #3: Escribir mal el nombre de una prop
```jsx
<Card namee="Alejo" career="Ingeniero" />
```

No pasa nada, **React ignora** `namee`.

Solo te sale un hueco vac√≠o, y pierdes tiempo buscando el fallo.

Pero **TypeScript** te diria algo tipo:
> ‚ùå Object literal may only specify known properties, and 'namee' does not exist in type 'CardProps'.

---

### Conclusi√≥n:

**TypeScript es como un cintur√≥n de seguridad üöó**

No evita el camino, pero te protege de los golpes que te dar√≠as con errores bobos.

---

## ‚úÖ Buenas pr√°cticas con props

* No **mutar** props: si necesitas cambiar algo, pide al padre que cambie (ver *lifting state up* m√°s abajo).
* Evita pasar objetos mutables sin copias si el hijo los va a transformar.
* Tipar bien las props con `type` o `interface` para evitar errores en tiempo de compilaci√≥n.

---

## üîπ ¬øQu√© es el *state*?

**State** es el **estado local** de un componente: datos que pueden cambiar con el tiempo (por interacci√≥n del usuario, respuestas de APIs, timers).
Se gestiona con el hook `useState`.

### Caracter√≠sticas clave del state

* Es **local** al componente donde se declara (salvo que lo subas a un padre).
* Cuando cambias el state, React **re-renderiza** el componente.
* No debes mutar directamente los valores del state; hay que usar la funci√≥n set que te entrega `useState`.

### Ejemplo: contador

```tsx
// Counter.tsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState<number>(0);

  function increment() {
    setCount(prev => prev + 1); // forma segura
  }

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={increment}>+1</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

**Puntos importantes:**

* `useState<number>(0)` ‚Üí el gen√©rico `<number>` tipa el estado (a veces TypeScript lo infiere, pero es buena pr√°ctica para claridad).
* `setCount(prev => prev + 1)` ‚Üí **functional update**: usa el valor anterior `prev` para calcular el nuevo. Esto evita bugs cuando haces varias actualizaciones seguidas.
* Nunca hagas `count = count + 1` ‚Äî no funciona y rompe las reglas de React.

---

## ‚ö†Ô∏è State con objetos o arrays

Cuando el state es un objeto o array, **no debes mutarlo**: crea una copia y actualiza esa copia.

### Objeto (ejemplo)

```tsx
type Profile = { name: string; age: number };

const [profile, setProfile] = useState<Profile>({ name: "Alejo", age: 21 });

// Para cambiar solo la edad:
setProfile(prev => ({ ...prev, age: prev.age + 1 }));
```

### Array (ejemplo)

```tsx
const [items, setItems] = useState<string[]>([]);

// a√±adir:
setItems(prev => [...prev, "nuevo"]);

// eliminar (filtrar):
setItems(prev => prev.filter((it, i) => i !== indexToRemove));
```

-> `prev.filter(...)`

El m√©todo `.filter()` de JavaScript **crea un nuevo array**, manteniendo solo los elementos que **cumplen una condici√≥n**.

Ejemplo:

```js
const frutas = ["manzana", "pera", "uva"];
const sinPera = frutas.filter(f => f !== "pera");
// sinPera = ["manzana", "uva"]
```

-> `(it, i) => i !== indexToRemove`

Esa es la funci√≥n que decide **qu√© elementos se quedan** en el nuevo array.

* it ‚Üí es cada elemento del array (por ejemplo, `"pera"`)
* i ‚Üí es el √≠ndice (posici√≥n en el array: 0, 1, 2, ‚Ä¶)
* `indexToRemove` ‚Üí es una variable que t√∫ decides (por ejemplo `1` si quieres borrar el segundo elemento)

Entonces `i !== indexToRemove` significa:

> Mant√©n todos los elementos excepto el que est√© en la posici√≥n que quiero eliminar

Ejemplo:

```tsx
const [items, setItems] = useState(["pan", "leche", "queso"]);

const indexToRemove = 1; // eliminar el segundo (leche)

setItems(prev => prev.filter((it, i) => i !== indexToRemove));
```

---

## üß† Comportamiento del state: asincron√≠a y batching

* `setState` no actualiza el valor **inmediatamente**; React decide cu√°ndo re-renderizar (por rendimiento).
* Por eso usar `prev => ...` es la forma segura cuando la nueva valor depende del anterior.
* React agrupa (batching) m√∫ltiples `setState` en el mismo evento para optimizar renders.

---

## üîÅ Lifting state up (elevar el estado)

A veces varios componentes necesitan leer o modificar el mismo estado. La soluci√≥n: **mover ese state al ancestro com√∫n** (normalmente el padre) y pasar el valor y las funciones como props.

### Ejemplo corto: padre controla el estado

```tsx
// App.tsx (padre)
import { useState } from "react";
import Child from "./Child";

export default function App() {
  const [name, setName] = useState("Alejo");

  return (
    <>
      <p>Nombre desde App: {name}</p>
      <Child onChangeName={setName} />
    </>
  );
}

// Child.tsx
type ChildProps = { onChangeName: (n: string) => void };

export default function Child({ onChangeName }: ChildProps) {
  return (
    <button onClick={() => onChangeName("Mar√≠a")}>Cambiar nombre</button>
  );
}
```

* `App` tiene el state `name`.
* `App` pasa `setName` (o mejor, una funci√≥n handler) como prop `onChangeName` al hijo.
* El hijo llama esa funci√≥n para pedir al padre que actualice el estado.

---

## üß≠ ¬øCu√°ndo usar props y cu√°ndo state?

* **Props**: cuando un componente necesita **datos desde fuera** (configuraci√≥n, contenido est√°tico que viene del padre).
* **State**: cuando los datos **cambian dentro del componente** (inputs, toggles, contadores, datos cargados desde APIs).
* Si varios componentes necesitan el mismo dato, guarda ese dato en el **padre** y p√°salo por props (o usa Context en caso m√°s avanzado).

---

## üìé Ejercicios pr√°cticos (con pistas y soluciones)

### Ejercicio 1 ‚Äî `Card` con props

**Objetivo:** crear `Card` que reciba `name`, `career`, `hobby` y muestre la info.
**Pistas:** usa `type CardProps`, `hobby` opcional, y destructuring.

**Soluci√≥n (ejemplo):**

```tsx
// Card.tsx
type CardProps = { name: string; career: string; hobby?: string };

export default function Card({ name, career, hobby }: CardProps) {
  return (
    <div style={{ border: "1px solid #ccc", padding: 10, borderRadius: 6 }}>
      <h4>{name}</h4>
      <small>{career}</small>
      {hobby && <p>Hobby: {hobby}</p>}
    </div>
  );
}
```

### Ejercicio 2 ‚Äî `Counter` con state

**Objetivo:** crear un contador con botones `+1`, `-1` y `Reset`.
**Pistas:** `useState<number>(0)`, usa `setCount(prev => prev + 1)`.

**Soluci√≥n (ejemplo):**

```tsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState<number>(0);
  return (
    <div>
      <p>{count}</p>
      <button onClick={() => setCount(prev => prev + 1)}>+1</button>
      <button onClick={() => setCount(prev => prev - 1)}>-1</button>
      <button onClick={() => setCount(0)}>Reset</button>
    </div>
  );
}
```

### Ejercicio 3 ‚Äî Comunicaci√≥n padre-hijo

**Objetivo:** crear `NameForm` (hijo) con un `<input>` y un bot√≥n ‚ÄúEnviar‚Äù; al enviar, el padre muestra el nombre.
**Pistas:** padre tiene `const [name, setName] = useState("")`; pasa `onSubmit` al hijo; en el hijo, maneja el input local y llama `onSubmit(value)`.

**Soluci√≥n (esqueleto):**

```tsx
// App.tsx (padre)
import { useState } from "react";
import NameForm from "./NameForm";

export default function App() {
  const [name, setName] = useState("");
  return (
    <>
      <p>Nombre guardado: {name}</p>
      <NameForm onSubmit={setName} />
    </>
  );
}

// NameForm.tsx (hijo)
import { useState } from "react";
type Props = { onSubmit: (n: string) => void };

export default function NameForm({ onSubmit }: Props) {
  const [value, setValue] = useState("");
  return (
    <form onSubmit={(e) => { e.preventDefault(); onSubmit(value); }}>
      <input value={value} onChange={e => setValue(e.target.value)} />
      <button type="submit">Enviar</button>
    </form>
  );
}
```

---

## üîß Errores comunes y c√≥mo evitarlos

* **Mutar el state directamente** (`profile.name = "X"`): provoca que React no detecte cambios. Usa copias (`{ ...profile }`).
* **No usar functional updates** cuando la nueva versi√≥n depende de la previa y generas race conditions.
* **No tipar las props**: lleva a errores que TypeScript podr√≠a haber detectado.
* **Olvidar `key` en listas** (tema del siguiente m√≥dulo `lists.md`): causa render inesperado.

---

## üìö Resumen r√°pido (para memoria)

* **Props** = datos que vienen del padre ‚Üí *inmutables* en el hijo.
* **State** = datos locales que cambian con el tiempo ‚Üí actual√≠zalos con `useState`.
* Para compartir estado entre componentes: **elevar el state** al ancestro com√∫n y pasar handlers como props.

---

Made with ‚ù§Ô∏è by **Alejo (DevByLualmara)**
